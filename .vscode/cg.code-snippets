{
    "DDA Line Drawing": {
        "scope": "c,cpp",
        "prefix": "dda",
        "body": [
            "#include <stdio.h>",
            "#include <conio.h>",
            "#include <graphics.h>",
            "#include <math.h>",
            "",
            "void draw(int x1, int y1, int x2, int y2);",
            "",
            "int main() {",
            "    int x1, y1, x2, y2;",
            "    int gdriver = DETECT, gmode;",
            "    initgraph(&gdriver, &gmode, \"\");",
            "",
            "    printf(\"Enter x1 y1: \");",
            "    scanf(\"%d%d\", &x1, &y1);",
            "",
            "    printf(\"Enter x2 y2: \");",
            "    scanf(\"%d%d\", &x2, &y2);",
            "",
            "    draw(x1, y1, x2, y2);",
            "",
            "    getch();",
            "    closegraph();",
            "    return 0;",
            "}",
            "",
            "void draw(int x1, int y1, int x2, int y2) {",
            "    float dx = x2 - x1;",
            "    float dy = y2 - y1;",
            "    int steps = (abs(dx) > abs(dy)) ? abs(dx) : abs(dy);",
            "    float xInc = dx / steps;",
            "    float yInc = dy / steps;",
            "    float x = x1;",
            "    float y = y1;",
            "    for (int i = 0; i <= steps; i++) {",
            "        putpixel(round(x), round(y), WHITE);",
            "        x += xInc;",
            "        y += yInc;",
            "    }",
            "}"
        ],
        "description": "DDA line drawing algorithm without Turbo path"
    },

    "Midpoint Circle Algorithm": {
        "scope": "c,cpp",
        "prefix": "circle",
        "body": [
            "#include <stdio.h>",
            "#include <conio.h>",
            "#include <graphics.h>",
            "#include <math.h>",
            "",
            "void circlepoint(int x, int y, int xc, int yc) {",
            "    putpixel(x + xc, y + yc, WHITE);",
            "    putpixel(y + xc, x + yc, WHITE);",
            "    putpixel(-x + xc, y + yc, WHITE);",
            "    putpixel(-y + xc, x + yc, WHITE);",
            "    putpixel(-x + xc, -y + yc, WHITE);",
            "    putpixel(-y + xc, -x + yc, WHITE);",
            "    putpixel(x + xc, -y + yc, WHITE);",
            "    putpixel(y + xc, -x + yc, WHITE);",
            "}",
            "",
            "int main() {",
            "    int driver = DETECT, mode;",
            "    initgraph(&driver, &mode, \"\");",
            "",
            "    int x = 0, y, d, r, xc, yc;",
            "    int x1 = getmaxx() / 2;",
            "    int y1 = getmaxy() / 2;",
            "    line(x1, 0, x1, 2 * y1);",
            "    line(0, y1, 2 * x1, y1);",
            "",
            "    printf(\"Enter radius: \");",
            "    scanf(\"%d\", &r);",
            "    printf(\"Enter center coordinates: \");",
            "    scanf(\"%d %d\", &xc, &yc);",
            "",
            "    xc = xc + x1;",
            "    yc = yc + y1;",
            "",
            "    y = r;",
            "    d = 1 - r;",
            "",
            "    while (x <= y) {",
            "        circlepoint(x, y, xc, yc);",
            "        if (d < 0)",
            "            d += 2 * x + 3;",
            "        else {",
            "            d += 2 * (x - y) + 5;",
            "            y--;",
            "        }",
            "        x++;",
            "    }",
            "",
            "    getch();",
            "    closegraph();",
            "    return 0;",
            "}"
        ],
        "description": "Midpoint Circle Algorithm using graphics.h (no Turbo path)"
    },

    "Midpoint Ellipse Program": {
        "scope": "c",
        "prefix": "ellipse",
        "body": [
            "#include <stdio.h>",
            "#include <graphics.h>",
            "#include <math.h>",
            "",
            "void display(int x, int y, int xc, int yc) {",
            "    putpixel(xc + x, yc + y, WHITE);",
            "    putpixel(xc - x, yc + y, WHITE);",
            "    putpixel(xc + x, yc - y, WHITE);",
            "    putpixel(xc - x, yc - y, WHITE);",
            "}",
            "",
            "int main() {",
            "    int gd = DETECT, gm;",
            "    int rx, ry, xc, yc;",
            "    float p1, p2, x, y;",
            "",
            "    initgraph(&gd, &gm, \"\");",
            "",
            "    printf(\"Enter center (xc yc): \");",
            "    scanf(\"%d %d\", &xc, &yc);",
            "    printf(\"Enter radii (rx ry): \");",
            "    scanf(\"%d %d\", &rx, &ry);",
            "",
            "    x = 0;",
            "    y = ry;",
            "    p1 = (ry * ry) - (rx * rx * ry) + (0.25 * rx * rx);",
            "",
            "    while ((2 * ry * ry * x) <= (2 * rx * rx * y)) {",
            "        display(x, y, xc, yc);",
            "        if (p1 < 0)",
            "            p1 += 2 * ry * ry * (x + 1) + ry * ry;",
            "        else {",
            "            p1 += 2 * ry * ry * (x + 1) - 2 * rx * rx * (y - 1) + ry * ry;",
            "            y--;",
            "        }",
            "        x++;",
            "    }",
            "",
            "    p2 = (ry * ry) * (x + 0.5) * (x + 0.5) + (rx * rx) * (y - 1) * (y - 1) - (rx * rx * ry * ry);",
            "",
            "    while (y >= 0) {",
            "        display(x, y, xc, yc);",
            "        if (p2 > 0)",
            "            p2 += -2 * rx * rx * (y - 1) + rx * rx;",
            "        else {",
            "            p2 += 2 * ry * ry * (x + 1) - 2 * rx * rx * (y - 1) + rx * rx;",
            "            x++;",
            "        }",
            "        y--;",
            "    }",
            "",
            "    getch();",
            "    closegraph();",
            "    return 0;",
            "}"
        ],
        "description": "Midpoint Ellipse Algorithm using graphics.h"
    },

    "2D Transformation Program": {
        "scope": "c",
        "prefix": "transform",
        "body": [
            "#include <stdio.h>",
            "#include <graphics.h>",
            "#include <math.h>",
            "",
            "int main() {",
            "    int gd = DETECT, gm;",
            "    int x1, y1, x2, y2, x3, y3;",
            "    int nx1, ny1, nx2, ny2, nx3, ny3;",
            "    int choice;",
            "    int tx, ty, sx, sy, angle;",
            "    float rad;",
            "",
            "    initgraph(&gd, &gm, \"\");",
            "",
            "    printf(\"Enter triangle coordinates: \");",
            "    scanf(\"%d %d %d %d %d %d\", &x1, &y1, &x2, &y2, &x3, &y3);",
            "",
            "    setcolor(WHITE);",
            "    line(x1, y1, x2, y2);",
            "    line(x2, y2, x3, y3);",
            "    line(x3, y3, x1, y1);",
            "",
            "    printf(\"\\n1. Translation\\n2. Rotation\\n3. Scaling\\n4. Exit\\nEnter choice: \");",
            "    scanf(\"%d\", &choice);",
            "",
            "    switch (choice) {",
            "        case 1:",
            "            printf(\"Enter translation (tx ty): \");",
            "            scanf(\"%d %d\", &tx, &ty);",
            "            nx1 = x1 + tx; ny1 = y1 + ty;",
            "            nx2 = x2 + tx; ny2 = y2 + ty;",
            "            nx3 = x3 + tx; ny3 = y3 + ty;",
            "            break;",
            "        case 2:",
            "            printf(\"Enter rotation angle in degrees: \");",
            "            scanf(\"%d\", &angle);",
            "            rad = angle * M_PI / 180.0;",
            "            nx1 = round(x1 * cos(rad) - y1 * sin(rad)); ny1 = round(x1 * sin(rad) + y1 * cos(rad));",
            "            nx2 = round(x2 * cos(rad) - y2 * sin(rad)); ny2 = round(x2 * sin(rad) + y2 * cos(rad));",
            "            nx3 = round(x3 * cos(rad) - y3 * sin(rad)); ny3 = round(x3 * sin(rad) + y3 * cos(rad));",
            "            break;",
            "        case 3:",
            "            printf(\"Enter scaling (sx sy): \");",
            "            scanf(\"%d %d\", &sx, &sy);",
            "            nx1 = x1 * sx; ny1 = y1 * sy;",
            "            nx2 = x2 * sx; ny2 = y2 * sy;",
            "            nx3 = x3 * sx; ny3 = y3 * sy;",
            "            break;",
            "        default:",
            "            closegraph();",
            "            return 0;",
            "    }",
            "",
            "    setcolor(YELLOW);",
            "    line(nx1, ny1, nx2, ny2);",
            "    line(nx2, ny2, nx3, ny3);",
            "    line(nx3, ny3, nx1, ny1);",
            "",
            "    getch();",
            "    closegraph();",
            "    return 0;",
            "}"
        ],
        "description": "2D Transformations (Translation, Rotation, Scaling)"
    },

    "DDA Assignment Notes": {
        "scope": "markdown,txt,cpp,c",
        "prefix": "ddaassignment",
        "body": [
            "# DDA Assignment",
            "",
            "## Q1. What is a line and what are its properties?",
            "Ans: A line is a collection of sub-points between initial and final points aligned in a straight manner.",
            "Any straight line is defined by two points between which the line passes.",
            "",
            "**PROPERTIES:**",
            "i) Slope intercept – y = mx + c",
            "   - where x & y = coordinate points",
            "   - m = slope",
            "   - c = intercept",
            "ii) slope = m = (y2 – y1) / (x2 – x1)",
            "",
            "## Q2. Write down DDA (Digital Differential Analyzer) algorithm",
            "Procedure (in DDA (x1,y1),(x2,y2): int):",
            "",
            "**STEP 1:** Var Dx,Dy,steps,k:int ",
            "            xInc,yInc,x,y:real",
            "",
            "**STEP 2:** → Begin",
            "  → DX = x2 – x1",
            "  → DY = y2 – y1",
            "",
            "**STEP 3:** → if abs(DX) > abs(DY)",
            "  then steps = abs(DX)",
            "  else steps = abs(DY)",
            "",
            "**STEP 4:** → xInc = DX / steps",
            "  → yInc = DY / steps",
            "  → x = x1",
            "  → y = y1",
            "",
            "**STEP 5:** → setpixel (round(x), round(y), 1)",
            "",
            "**STEP 6:** → for (k = 1 to steps) do",
            "  → Begin",
            "  → x = x + xInc",
            "  → y = y + yInc",
            "",
            "**STEP 7:** → Repeat step 2 to step 6"
        ],
        "description": "Detailed DDA Assignment Notes"
    },

    "Transformation Assignment Notes": {
        "scope": "markdown,txt,cpp,c",
        "prefix": "transformnotes",
        "body": [
            "# Transformation Assignment",
            "## Introduction",
            "In computer graphics, a transformation means changing the position, shape, size, or orientation of an object in a coordinate system.",
            "It allows us to move or modify objects on the screen using mathematical operations.",
            "Every transformation can be represented using a transformation matrix, which helps in performing the changes accurately.",
            "",
            "## Main Types of Transformations",
            "",
            "### 1) Translation",
            "Translation means shifting an object from one position to another without changing its shape, size, or orientation.",
            "It simply moves the object by adding a fixed value to its X and Y coordinates.",
            "Formula:",
            "x' = x + tx",
            "y' = y + ty",
            "Where tx and ty are translation distances along the x and y axes.",
            "Explanation:",
            "If an object is originally at (x, y), after translation it moves to a new location (x', y').",
            "This is commonly used to move shapes, characters, and images on the screen.",
            "",
            "### 2) Scaling",
            "Scaling changes the size of an object. It can enlarge or shrink an object based on the scaling factors.",
            "Formula:",
            "x' = Sx × x",
            "y' = Sy × y",
            "Where Sx and Sy are scaling factors along the x and y axis.",
            "Explanation:",
            "If Sx, Sy > 1, the object becomes bigger.",
            "If Sx, Sy < 1, the object becomes smaller.",
            "Scaling is useful for zooming in or out of graphical objects.",
            "",
            "### 3) Rotation",
            "Rotation means turning an object around the origin (0,0) or a fixed point by a certain angle.",
            "Formula:",
            "x' = x cosθ – y sinθ",
            "y' = x sinθ + y cosθ",
            "Where θ is the rotation angle.",
            "Explanation:",
            "Rotation changes the orientation of the object while keeping its size and shape same.",
            "It is used to turn shapes clockwise or counterclockwise on the screen."
        ],
        "description": "Detailed Transformation Assignment Notes"
    },
	"Circle Assignment Notes": {
    "scope": "markdown,txt,cpp,c",
    "prefix": "circlenotes",
    "body": [
        "# Circle Assignment",
        "",
        "## Definition & Properties",
        "A circle is the set of all points in a plane that are equidistant from a fixed point called the center.",
        "The distance from the center to any point on the circle is called the radius (r).",
        "",
        "**Properties:**",
        "1) Radius (r) – distance from center to any point on the circle",
        "2) Center (xc, yc) – fixed point in the plane",
        "3) Circumference = 2πr",
        "4) Equation of circle: (x - xc)^2 + (y - yc)^2 = r^2",
        "5) Parametric form: x = xc + r cosθ, y = yc + r sinθ, θ ∈ [0, 360°]",
        "6) Symmetry: Circle is symmetric about its center in all directions",
        "",
        "## Midpoint Circle Algorithm Steps",
        "The Midpoint Circle Algorithm is an efficient way to draw a circle using pixel coordinates without floating-point calculations.",
        "",
        "### Steps:",
        "1) Input radius r and center (xc, yc)",
        "2) Set initial point (x0, y0) = (0, r) and decision parameter p0 = 1 - r",
        "3) For each step, increment x by 1 and determine next y based on decision parameter pk:",
        "   - If pk < 0 → next point is (xk+1, yk), pk+1 = pk + 2*xk+1 + 1",
        "   - Else → next point is (xk+1, yk+1), pk+1 = pk + 2*xk+1 - 2*yk+1 + 1",
        "4) Use symmetry to plot all eight points corresponding to the current (x, y)",
        "5) Repeat steps until x >= y",
        "",
        "### Explanation:",
        "- The algorithm calculates the next pixel position using a decision parameter to decide whether to decrement y or not.",
        "- Using symmetry reduces computation by plotting 8 points simultaneously.",
        "- Efficient for raster graphics as it avoids floating-point multiplication and division."
    ],
    "description": "Detailed Circle Assignment Notes"
},"Ellipse Assignment Notes": {
    "scope": "markdown,txt,cpp,c",
    "prefix": "ellipsenotes",
    "body": [
        "# Ellipse Assignment",
        "",
        "## Definition & Properties",
        "An ellipse is a set of all points such that the sum of distances from two fixed points called foci is constant.",
        "It can also be thought of as a deformed circle with two different axes.",
        "",
        "**Properties:**",
        "1) Two axes: Major axis (longest diameter) and Minor axis (shortest diameter)",
        "2) Center (xc, yc) – midpoint of the axes",
        "3) Radii: rx (horizontal), ry (vertical)",
        "4) Eccentricity e = sqrt(1 - (ry^2/rx^2)) for rx > ry",
        "5) Standard equation: ((x - xc)/rx)^2 + ((y - yc)/ry)^2 = 1",
        "6) Parametric form: x = xc + rx cosθ, y = yc + ry sinθ",
        "7) Symmetry: Ellipse is symmetric about both axes",
        "",
        "## Midpoint Ellipse Algorithm Steps",
        "The Midpoint Ellipse Algorithm is used to plot points of an ellipse efficiently in raster graphics.",
        "",
        "### Steps:",
        "1) Input center (xc, yc) and radii (rx, ry)",
        "2) Start at initial point (0, ry)",
        "3) Region 1 (slope < 1): Increment x by 1, calculate decision parameter p1:",
        "   - If p1 < 0 → y stays same, p1 updated accordingly",
        "   - Else → decrement y by 1, p1 updated accordingly",
        "4) Region 2 (slope > 1): Decrement y by 1, calculate decision parameter p2:",
        "   - If p2 > 0 → x stays same, p2 updated accordingly",
        "   - Else → increment x by 1, p2 updated accordingly",
        "5) For each calculated point, use symmetry to plot four points: (±x, ±y) relative to center",
        "6) Repeat until the ellipse is complete",
        "",
        "### Explanation:",
        "- Decision parameters help avoid floating-point calculations, improving performance.",
        "- Symmetry reduces computation by plotting multiple points simultaneously.",
        "- Region division ensures proper pixel approximation along the curve."
    ],
    "description": "Detailed Ellipse Assignment Notes"
}


}
